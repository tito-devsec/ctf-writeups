# CTF Write-up: TZCERTHackgame

**Category:** Web
**Challenge Source:** tcraCyber champion 2026
**Write-up Author:** TitoDevsec (T1t0D3v$3c)

## Challenge Summary
The target was a simple "hackgame" where the goal was to "beat the guy in the suit" to win the prize. The game actions were sent to an API endpoint.

## Vulnerability Analysis
### What was wrong?
The application was vulnerable to **Insecure Direct Object Reference (IDOR)** or **Broken Access Control**. The server trusted the `attack` value and `token` sent from the client without properly validating the game state or the round outcome.

## Solution
1.  **Interception:** Use a tool like Burp Suite to intercept the request made when starting a round.
    ```bash
    POST /api/round
    {
        "attack": 1,
        "token": "<token>"
    }
    ```
2.  **Identification:** The server trusts the `attack` value and `token` from the client and returns the updated game state in JSON.
3.  **Exploitation:** Replay the `POST /api/round` request with a modified `attack` value to produce maximum damage.
    ```bash
    POST /api/round
    {
        "attack": 999999,
        "token": "<token>"
    }
    ```
4.  **Result:** The server responds with `hpEnemy: 0` and includes the flag directly in the JSON response.

## Code Comparison

### Vulnerable Code (Conceptual)
Trusting client-side input for game state updates:
```python
# Flask endpoint (Vulnerable)
@app.route('/api/round', methods=['POST'])
def round():
    data = request.get_json()
    attack = data.get('attack')
    token = data.get('token')
    # Server trusts the attack value from the client
    game_state = update_game_state(token, attack)
    if game_state.hpEnemy <= 0:
        return jsonify({"hpEnemy": 0, "flag": FLAG})
    return jsonify(game_state)
```

### Secure Code
All game logic and state updates should be handled server-side. The client should only send the *action* (e.g., "attack"), and the server should calculate the damage based on the current game state and the player's attributes.
```python
# Flask endpoint (Secure)
@app.route('/api/round', methods=['POST'])
def round():
    data = request.get_json()
    token = data.get('token')
    # Server calculates damage based on trusted state
    game_state = get_game_state(token)
    damage = calculate_damage(game_state.player)
    game_state.hpEnemy -= damage
    # ... save and return state
```

## Lessons Learned
*   **Never Trust the Client:** Any value sent from the client (like damage or attack values) can be manipulated and must be validated or calculated on the server.
*   **Server-Side Logic:** Critical game logic and state transitions should always be handled on the server to prevent cheating and exploitation.
*   **API Validation:** Always validate and sanitize all inputs to an API, ensuring they fall within expected ranges and types.

## Flag
`tzcert{e264a375bc351b695b184eca95758876}`
